##############################
# APS106 Winter 2022 - Lab 4 #
##############################

import math

def heat_control_hysteresis_thresh(temp_measured, current_state, temp_desired, alpha):
    """
    (float, bool, float, float) -> bool
    
    Implement a hysteresis threshold to determine and return the
    next state of the heater using the current state, latest measurement,
    desired temperature, and hyteresis buffer range (+/- alpha). 
    
    >>> heat_control_hysteresis_thresh(33.2, True, 40.0, 5.0)
    True
    
    >>> heat_control_hysteresis_thresh(28.4, True, 27.5, 1.0)
    True
    
    >>> heat_control_hysteresis_thresh(50.6, True, 40.0, 10.0)
    False
    
    >>> heat_control_hysteresis_thresh(30.8, False, 40.0, 2.9)
    True
    """    
    
    # use if statements to compare the desired temperature to the current temperature and determine the next state of the heater based on the results of the comparison
    
    # if the measured temperature is less than the desired temperature minus alpha, the heater should be on
    
    if temp_measured < (temp_desired - alpha):
        next_state = True
    
    #if the meaured temperature is greater than the desired temperature plus alpha, the heater should be off
    
    if temp_measured > (temp_desired + alpha):
        next_state = False
    
    # if the absolute value of the difference between desired and actual temperature is less or equal to the threshold range alpha, the next state should be the same as the current state
    
    if (abs(temp_measured - temp_desired)) <= alpha:
        next_state = current_state
        
        
        
    return next_state


def newton_raphson_sqrt(n, epsilon):
    """
    (float,float) -> float
    
    Calcualtes the square root of a number, n, using the Newton-Raphson method.
    Returned value is the square root of n within tolerance amount
    specified by epsilon.
    
    >>> newton_raphson_sqrt(4.0,0.001)
    2.0
    
    >>> newton_raphson_sqrt(2.0, 0.1)
    1.417

    """
    
    # the intial value for the approximaiton x_i is n
    
    x_i = n
    
    # use a while loop to check if calculated tolerance is greater than the given tolerance, if it is, calculate the next iteration of x_i
    
    while (abs((x_i ** 2) - n)) > epsilon:
        
        # change the value for x_i by using its curren value to calculate the next iteration
        
        x_i = 0.5 * (x_i + (n/x_i))
        
        
    # round the approximated root to three decimal places
        
    x_i_rounded = round(x_i, 3)
        
              
    return x_i_rounded


def get_sensor_measurement(t,c0,c1,c2,c3,c4):
    """
    (float,float,float,float,float,float) -> float
    
    Simulates a sensor value reading. The value returned by the 
    function is generated by from the following equation:
        
        s(t) = c0*t + c1*sqrt(t) + c2*sin(t) + c3*cos(8t) + c4
        
    where t, c0, c1, c2, c3, and c4 are parameters passed into the function.
    The returned value is rounded to 3 decimal points.
    
    DO NOT EDIT THIS FUNCTION
    """
    measurement = c0*t + c1*newton_raphson_sqrt(abs(t),0.0005) + c2*math.sin(t) + c3*math.cos(8*t) + c4
    return round(measurement,3)



def thresh_crossing_counter(temp_desired, hyst_alpha,
                            t_start,t_stop,
                            c0,c1,c2,c3,c4):
    """
    (float, float, float, float, float, float, float, float, float) -> int
    
    Counts the number of times a simulated sensor measurement crosses a 
    hysteresis threshold.
    
    >>> thresh_crossing_counter(0.0, 0.2, 0.0, 10.01, -0.1, 2.0, 10.0, -5.0, -1.0)
    10
    """
    t_step = 0.05 # amount to increment the time after each sensor reading
    
    # Initialize the state
    # simply compare to the desired temperature because we don't yet know
    # the current state to use the hysteresis threshold
    state = get_sensor_measurement(t_start,c0,c1,c2,c3,c4) <= temp_desired 

    # initialize a counter for the number of times the state changes
    counter = 0
    
    # create a variable to store the end point of an interval
    
    t = (t_start + t_step)
    
    
    # create a loop to iterate through every 0.05 seconds of the time interval

    while t <= t_stop:
        
        # find the temperature at the end point of the interval by getting the temperature at t and adding alpha to it, and then comparing it to the desired temperature
        
        end_state = (get_sensor_measurement(t, c0, c1, c2, c3, c4) + hyst_alpha) <= temp_desired
        
        # find out whether the state of the heater is different from the beginning compared to at the end, increase the counter by one if this is true
        
        if state != end_state:
            counter += 1
            
        # make the starting point of the next interval the end point of the current interval
        
        state = end_state
        
        # increment t by the step size
        
        t += t_step
        
          
    return counter

if __name__ == '__main__':
    import doctest
    doctest.testmod()

